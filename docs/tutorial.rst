Tutorial: Word Error Rate and normalization
===========================================

In this step-by-step tutorial you will compare the Word Error Rate (WER) of two machine-generated transcripts. The WER is calculated against a less-than-perfect reference made from a human-generated subtitle file. You will also use normalization rules to improve the accuracy of the results.

To follow this tutorial you will need a working installation of ``benchmarkstt`` and these source files saved to your working folder:

* `Subtitle file <_static/demos/qt_subs.xml>`_
* `Transcript generated by AWS <_static/demos/qt_aws.json>`_ 
* `Transcript generated by Kaldi <_static/demos/qt_kaldi.json>`_ 

This demo shows the capabilities of Release 1 of the library, which benchmarks the accuracy of word recognition only. The library supports adding new metrics in future releases. Contributions are welcome. 

Make the "reference"
--------------------

Creating accurate verbatim transcripts for use as reference is time-consuming and expensive. As a quick and easy alternative, we will make a "reference" from a subtitles file. Subtitles are slightly edited and they include additional text like descriptions of sounds and actions, so they are not a verbatim transcription of the speech. Consequently, they are not suitable for calculating absolute WER. However, we are interested in calculating relative WER for illustration purposes only, so this use of subtitles is deemed acceptable. 

.. warning::

    This is a demo of work in progress. The benchmarking tool is still in development
    and evaluations are not done for the purpose of assessing tools. In addition, the use of
    subtitles as reference will skew the results so they should not be taken as an indication
    of overall performance or as an endorsement of a particular vendor or engine.

We will use the subtitles file for the BBC's Question Time Brexit debate. This program was chosen for its length (90 minutes) and because live debates are particularly challenging to transcribe.

The subtitles file includes a lot of extra text in XML tags. This text shouldn't be used in the calculation: for both reference and hypotheses, we want to run the tool on plain text only. To strip out the XML tags, we will use the :code:`benchmarkstt-tools` command, with the :code:`normalization` subcommand:  


.. code:: bash

    benchmarkstt-tools normalization --inputfile qt_subs.xml --outputfile qt_reference.txt --regex "<[^>]+>" " "

The normalization rule :code:`--regex` takes two parameters: a regular expression pattern and the replacement string. In this case all XML tags will be replaced with a space. This will result in a lot of space characters, but these are ignored by the diff algorithm later so we don't have to clean these up. :code:`--inputfile` and :code:`--outputfile` are the input and output files. 

The file :code:`qt_reference.txt` has been created. You can see that the XML tags are gone, but the file still contains non-dialogue text like 'APPLAUSE'.

For better results you can manually clean up the text, or run the command again with a different normalization rule (not included in this demo). But we will stop the normalization at this point.

We now have a simple text file that will be used as the reference. The next step is to get the machine-generated transcripts for benchmarking.


Make hypotheses
----------------

The first release of :code:`benchmarkstt` does not integrate directly with STT vendors or engines, so transcripts for benchmarking have to be retrieved separately and converted to plain text. 

For this demo, two machine transcripts were retrieved for the Question Time audio: from AWS Transcribe and from the BBC's version of Kaldi, an open-source STT framework.

Both AWS and BBC-Kaldi return the transcript in JSON format, with word-level timings. They also contain a field with the entire transcript as a single string, and this is the value we will use (we don't benchmark timings in this version). 

To make the hypothesis files, open the `transcript generated by AWS <_static/demos/qt_aws.json>`_, copy the contents of the :code:`transcript` field and save it as a new document :code:`qt_aws_hypothesis.txt`. Now open the `transcript generated by Kaldi <_static/demos/qt_kaldi.json>`_, copy the contents of the :code:`text` field and save it as a new document :code:`qt_kaldi_hypothesis.txt`.

You'll end up with two files similar to these:

* `Text extracted from AWS transcript <_static/demos/qt_aws_hypothesis.txt>`_ 
* `Text extracted from Kaldi transcript <_static/demos/qt_kaldi_hypothesis.txt>`_ 


Benchmark!
----------

We can now compare each of the hypothesis files to the reference in order to calculate the Word Error Rate. We process one file at a time, now using the main :code:`benchmarkstt` command, with two flags: :code:`--wer` is the metric to return; :code:`--diffcounts` returns the number of insertions, deletions, substitutions and correct words (the basis for WER calculation).


Calculate WER for AWS Transcribe:

.. code:: bash

  benchmarkstt --reference qt_reference.txt --hypothesis qt_aws_hypothesis.txt --wer --diffcounts

The output should look like this:

.. code::

    wer
    ===
    0.223073

    diffcounts
    ==========
    OpcodeCounts(equal=12376, replace=1022, insert=611, delete=1745)


Now calculate the WER for BBC-Kaldi:

.. code:: bash

  benchmarkstt --reference qt_reference.txt --hypothesis qt_kaldi_hypothesis.txt --wer --diffcounts


After running these two commands, you can see that the WER for both transcripts is quite high (around 30%). Let's see the actual differences between the reference and the hypotheses by adding the :code:`--worddiffs` flag:

.. code:: bash

  benchmarkstt --reference qt_reference.txt --hypothesis qt_kaldi_hypothesis.txt --wer --diffcounts --worddiffs


Normalize
---------

You can see that a lot of the differences are due to capitalization and punctuation. Because we are only interested in the correct identification of words, these types of differences should not count as errors. To get a more accurate WER, we will remove punctuation marks and convert all letters to lowercase. We will do this for the reference and both hypothesis files by using the :code:`benchmarkstt-tools normalization` subcommand again, with two rules: the built-in :code:`--lowercase`  rule and the :code:`--regex` rule:


.. code:: bash   

  benchmarkstt-tools normalization -i qt_reference.txt -o qt_reference_normalized.txt --lowercase --regex "[,.-]" " "

  benchmarkstt-tools normalization -i qt_kaldi_hypothesis.txt -o qt_kaldi_hypothesis_normalized.txt --lowercase --regex "[,.-]" " "

  benchmarkstt-tools normalization -i qt_aws_hypothesis.txt -o qt_aws_hypothesis_normalized.txt --lowercase --regex "[,.-]" " "

We now have normalized versions of the reference and two hypothesis files. 


Benchmark again
---------------

Let's run the :code:`benchmarkstt` command again, this time calculating WER based on the normalized files:

.. code:: bash

  benchmarkstt --reference qt_reference_normalized.txt --hypothesis qt_kaldi_hypothesis_normalized.txt --wer --diffcounts --worddiff

  benchmarkstt --reference qt_reference_normalized.txt --hypothesis qt_aws_hypothesis_normalized.txt --wer --diffcounts --worddiff

You can see that this time there are fewer differences between the reference and hypothesis. Accordingly, the WER is much lower for both hypotheses. The transcript with the lower WER is closer to the reference made from subtitles. 


Do it all in one step!
----------------------

Above, we used two commands: :code:`benchmarkstt-tools` for the normalization and :code:`benchmarkstt` for calculating the WER. But we can combine all these steps into a single command using a rules file and a config file tat references it. 

First, let's create a file for the regex normalization rules. Create a text document with this content:

.. code:: bash

    # Replace XML tags with a space
    "<[^>]+>"," "
    # Replace punctuation with a space
    "[,.-]"," "

Save this file as :code:`rules.regex`.


Now let's create a config file that contains all the normalization rules. They must be listed under the :code:`[normalization]` section (in this release, there is only one implemented section). The section references the regex rules file we created above, and also includes one of the built-in rules. 

.. code:: bash 

    [normalization]
    # Load regex rules file and tell the processor it's a regex type
    Regex rules.regex
    # Built in rule
    lowercase

Save the above as :code:`config.conf`. These rules will be applied to both hypothesis and reference, in the order in which they are listed.

Now run :code:`benchmarkstt` with the :code:`--conf` argument. We also need to tell the tool to treat the XML as plain text, otherwise it will look for an ``xml`` processor and fail. We do this with the 'reference type' argument :code:`-rt`:

.. code:: bash

    benchmarkstt --reference qt_subs.xml -rt plaintext --hypothesis qt_kaldi_hypothesis.txt --config normalization.conf --wer

And again for the other transcript, this time using the short form for arguments:

.. code:: bash

    benchmarkstt -r qt_subs.xml -rt plaintext -h qt_aws_hypothesis.txt --config normalization.conf --wer

You now have WER scores for each of the machine-generated transcripts, calculated against a subtitles reference file. As a next step, you could create additional normalization rules or compare the results of the standard WER against the Hunt variant by specifying :code:`--wer hunt`. Or you could implement your own metrics or normalizers and submit them back to this project.


